# AbstractQueuedSynchronizerTree
AbstractQueuedSynchronizer技术研究


![](https://i.imgur.com/c00Hobh.png)

<pre>
AQS：
       AQS提供了一种实现阻塞和一些列依赖FIFO等待队列同步器的框架；

       AQS为一系列同步器依赖于一个单独的原子变量state的同步器提供了一个非常有用的基础。子类
    必须定义改变state是如何获取或释放的。

       AQS中对state的操作是原子的，且不能被继承。所有的同步机制的实现均依赖对变量的原子操作
    。AQS并不实现任何借口，他提供了一些可以被具体实现类直接调用的一些原子操作方法来重写相应
    的同步逻辑。AQS同时提供了互斥模式exclusive和共享模式shared两种不同的同步逻辑。

    state：(原子操作)
         getState();
         setState();
         compareAndSetState(); （unsafe类中的方法）

    acquire(int)；
    tryAcquire(int)；
    addWaiter(Node)；
    enq(node)；
    acquireQueued(Node, int)；
    release(int)；
</pre>

<pre>
      AQS是一个Java提供的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列
      CAS操作来管理这个同步状态，AQS的主要作用是为Java中的并发同步组件提供统一的底层支持，
      例如ReentrantLock, CountDownLatch就是AQS实现的，用法是通过继承AQS实现其模板方法
      ，然后将子类作为同步组件的内部类。
</pre>

![](https://i.imgur.com/WqQTslD.png)

<pre>
同步队列

      同步队列是AQS很重要的组成部分，它是一个双端队列，遵循FIFO原则，主要作用是用来存放在
      锁上阻塞的线程，当一个线程尝试获取锁时，如果锁已经被占用，那么当前线程就会被构造成一
      个node节点加入到同步队列的尾部，队列的头节点是成功获取锁的节点，当头结点线程是非锁时
      ，会唤醒后面的节点并释放当前头结点的引用。
</pre>

<pre>
独占锁的获取与释放流程

      获取：
          1）调用入口方法acquire(arg)
          2) 调用模版方法tryAcquire(arg)尝试获取锁，若成功则返回，若失败则走下一步
          3）将当前线程构造成一个Node节点，并利用CAS将其加入到同步队列到尾部，然后该节点
             对应到线程进入自旋状态
          5）自旋时，首先判断其前驱节点释放为头节点&是否成功获取同步状态，两个条件都成立，
             则将当前线程的节点设置为头节点，如果不是，则利用LockSupport.park(this)将当
             前线程挂起 ,等待被前驱节点唤醒

      释放：
          1）调用入口方法release(arg)
          2）调用模版方法tryRelease(arg)释放同步状态
          3）获取当前节点的下一个节点
          5）利用LockSupport.unpark(currentNode.next.thread)唤醒后继节点（接获取的第四步）
</pre>

<pre>
共享锁的获取与释放

      获取锁：
      1）调用acquireShared(arg)入口方法
      2）进入tryAcquireShared(arg)模版方法获取同步状态，如果返返回值>=0，则说明同步状态
         (state)有剩余，获取锁成功直接返回
      3）如果tryAcquireShared(arg)返回值<0，说明获取同步状态失败，向队列尾部添加一个共享
         类型的Node节点，随即该节点进入自旋状态
      5）自旋时，首先检查前驱节点释放为头节点&tryAcquireShared()是否>=0(即成功获取同步状态)
      6）如果是，则说明当前节点可执行，同时把当前节点设置为头节点，并且唤醒所有后继节点
      7）如果否，则利用LockSupport.unpark(this)挂起当前线程，等待被前驱节点唤醒

      释放锁：
         1）调用releaseShared(arg)模版方法释放同步状态
         2）如果释放成，则遍历整个队列，利用LockSupport.unpark(nextNode.thread)唤醒所有后继节点
</pre>

<pre>
独占锁和共享锁在实现上的区别
     独占锁的同步状态值为1，即同一时刻只能有一个线程成功获取同步状态
     共享锁的同步状态>1，取值由上层同步组件确定
     独占锁队列中头节点运行完成后释放它的直接后继节点
     共享锁队列中头节点运行完成后释放它后面的所有节点
     共享锁中会出现多个线程（即同步队列中的节点）同时成功获取同步状态的情况
</pre>

<pre>
重入锁

      重入锁指的是当前线成功获取锁后，如果再次访问该临界区，则不会对自己产生互斥行为。Java
      中对ReentrantLock和synchronized都是可重入锁，synchronized由jvm实现可重入锁，
      ReentrantLock都可重入性基于AQS实现。
</pre>

![](https://i.imgur.com/eIew4DY.png)

<pre>
读写锁

      Java提供了一个基于AQS到读写锁实现ReentrantReadWriteLock，该读写锁到实现原理是：将
      同步变量state按照高16位和低16位进行拆分，高16位表示读锁，低16位表示写锁。

      写锁的获取与释放：
          1）获取同步状态，并从中分离出低16为的写锁状态
          2）如果同步状态不为0，说明存在读锁或写锁
          3）如果存在读锁（c ！=0 && w == 0），则不能获取写锁（保证写对读的可见性）
          5）如果当前线程不是上次获取写锁的线程，则不能获取写锁（写锁为独占锁）
          6）如果以上判断均通过，则在低16为写锁同步状态上利用CAS进行修改（增加写锁同步状态，实现可重入）
          7）将当前线程设置为写锁的获取线程

          在释放的过程中，不断减少读锁同步状态，只为同步状态为0时，写锁完全释放。

      读锁的读取与释放：
          读锁是一个共享锁，获取读锁的步骤如下：

          1）获取当前同步状态
          2）计算高16为读锁状态+1后的值
          3）如果大于能够获取到的读锁的最大值，则抛出异常
          5）如果存在写锁并且当前线程不是写锁的获取者，则获取读锁失败
          6）如果上述判断都通过，则利用CAS重新设置读锁的同步状态
          7）读锁的获取步骤与写锁类似，即不断的释放写锁状态，直到为0时，表示没有线程获取读锁
</pre>